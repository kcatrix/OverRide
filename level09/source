#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* * Structure logique telle qu'elle apparaît sur la pile 
 * dans la fonction handle_msg
 */
struct s_data {
    char message[140];  // Offset 0 (local_c8)
    char username[40]; // Offset 140 (param_1 + 0x8c)
    int len;           // Offset 180 (param_1 + 0xb4)
};

void set_username(struct s_data *data) {
    char input[140];
    int i;

    // Initialisation du buffer local à zéro
    memset(input, 0, 140);

    puts(">: Enter your username");
    printf(">>: ");
    
    // On lit jusqu'à 128 octets
    fgets(input, 128, stdin);

    /* * LA FAILLE : Off-by-one (ou presque) 
     * La boucle va jusqu'à 41 (0x29) alors que le username 
     * ne devrait faire que 40 octets.
     * Le 41ème octet écrase le début de 'data->len'.
     */
    for (i = 0; i < 41 && input[i] != '\0'; i++) {
        data->username[i] = input[i];
    }

    printf(">: Welcome, %s", data->username);
}

void set_msg(struct s_data *data) {
    char input[1024];

    // Initialisation du buffer local à zéro (boucle de 128 * 8 octets)
    memset(input, 0, 1024);

    puts(">: Msg @Unix-Dude");
    printf(">>: ");
    
    // On lit jusqu'à 1024 octets
    fgets(input, 1024, stdin);

    /* * LA FAILLE : Buffer Overflow
     * strncpy utilise 'data->len'. Si on a écrasé 'data->len' 
     * avec une grande valeur dans set_username, on peut copier 
     * beaucoup plus que les 140 octets prévus dans data->message.
     */
    strncpy(data->message, input, (long)data->len);
}

void handle_msg() {
    struct s_data data;

    // Initialisation de la structure sur la pile
    memset(data.message, 0, 140);
    memset(data.username, 0, 40);
    data.len = 140; // 0x8c en hexadécimal

    set_username(&data);
    set_msg(&data);

    puts(">: Msg sent!");
}

int main(void) {
    puts(
        "--------------------------------------------\n"
        "|   ~Welcome to l33t-m$n ~    v1337        |\n"
        "--------------------------------------------"
    );

    handle_msg();

    return 0;
}